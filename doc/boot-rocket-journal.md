### 10.22

#### Rocket chip


We don't have access to VCS simulator, but we can generate the synthesizable Verilog file with the commands:

```sh
make verilog CONFIG=freechips.rocketchip.system.DefaultFPGAConfig
```

The target Verilog will be generated in directory `vsim/generated-src`. What we need to know is how the `DefaultFPGAConfig` works. See `vsim/Makefrag-verilog` and keep tracking on all Makefile variables.

```Makefile
# Prepare for sbt and java environment
SBT ?= java -Xmx$(JVM_MEMORY) -Xss8M -jar $(base_dir)/sbt-launch.jar
JAVA ?= java -Xmx$(JVM_MEMORY) -Xss8M
FIRRTL ?= $(JAVA) -cp $(ROCKET_CHIP_JAR) firrtl.stage.FirrtlMain
GENERATOR ?= $(JAVA) -cp $(ROCKET_CHIP_JAR) $(PROJECT).Generator

# List all resource files in Rocket Chip project.
scala_srcs := $(shell find $(base_dir) -name "*.scala" -o -name "*.sbt")
resource_dirs := $(shell find $(base_dir) -type d -path "*/src/main/resources")
resources := $(foreach d,$(resource_dirs),$(shell find $(d) -type f))
all_srcs := $(scala_srcs) $(resources)

# Get rocket chip .jar file
ROCKET_CHIP_JAR := $(base_dir)/rocketchip.jar
$(ROCKET_CHIP_JAR): $(all_srcs)
	cd $(base_dir) && $(SBT) assembly

# Use pre-generated bootrom image
bootrom_img = $(base_dir)/bootrom/bootrom.img

# We need to change the CONFIG mannually
$(generated_dir)/%.fir $(generated_dir)/%.d: $(ROCKET_CHIP_JAR) $(bootrom_img)
	mkdir -p $(dir $@)
	cd $(base_dir) && $(GENERATOR) -td $(generated_dir) -T $(PROJECT).$(MODEL) -C $(CONFIG)

$(generated_dir)/%.v $(generated_dir)/%.conf: $(generated_dir)/%.fir $(ROCKET_CHIP_JAR)
	mkdir -p $(dir $@)
	$(FIRRTL) -i $< \
    -o $(generated_dir)/$*.v \
    -X verilog \
    --infer-rw $(MODEL) \
    --repl-seq-mem -c:$(MODEL):-o:$(generated_dir)/$*.conf \
    -faf $(generated_dir)/$*.anno.json \
    -td $(generated_dir)/$(long_name)/ \
    -fct $(subst $(SPACE),$(COMMA),$(FIRRTL_TRANSFORMS)) \
```

In conclusion, what we should prepare is:

- A bootrom image to load device tree and boot system softwares (uboot, linux). Maybe we can use RustSBI or OpenSBI instead.
- A device tree to let the generator know what the zcu102 board looks like
- A configuration written in Chisel and passed to the generator while building .fir file, which can be found in `src/main/scala/system`.

#### Build Rocket (default configs)

- First we need build [riscv-gnu-toolchain](https://github.com/riscv-collab/riscv-gnu-toolchain): run `./configure --prefix=/opt/riscv; make` to install `riscv64-unknown-elf-*` tools.
  - You might need to refer to the [README.md](https://github.com/riscv-collab/riscv-gnu-toolchain/README.md) to install dependencies.
- Set `RISCV` environment variable in your workspace. E.g. run `echo "export RISCV=/opt/riscv/; export PATH=$RISCV/bin:$PATH;" >> ~/.bashrc` to set it global.
- Get [riscv-tools](https://github.com/riscv-software-src/riscv-tools) and build it. E.g. run `sudo RISCV=/opt/riscv bash -c ./build.sh` because the toolchain is installed under a directory which can be modified only with root permission.
  - See [this issue](https://github.com/riscv-software-src/riscv-tests/issues/286): add `-fcommon` to `RISCV_GCC_OPTS` because cuurent version of gcc compilers sets `-fno-common` by default.

### 10.27

#### Build Labeled-RISC-V-N on zcu102

- Install vivado 2020.2
- Build Labeled-RISC-V-N with `.v`s generated by modified Rocket Chip and block design by existing `.tcl` scripts.

### 10.31~11.1

#### Learn MPSOC

- **PS**: ARM cores; **PL**: FPGA
- AXI DMA:
  - 2 channels: memory mapped to stream (mm2s) and stream to memory mapped (s2mm)
  - AXI Memory Mapped: For DDR data. (write address channel, write data channel, write response channel, read address channel, read data channel).
  - AXI Lite: For configuring registers.
  - AXI Stream: Writes or reads peripherals.
  - `M_AXI_MM2S`: DMA reads data from DDR.
  - `M_AXI_S2MM`: DMA writes data to DDR.
  - `M_AXIS_MM2S`: DMA writes data to stream interface.
  - `S_AXIS_S2MM`: DMA reads data from stream interface.
  - `mm2s_introut`: (Interrupt) reads from DDR and writes to stream interface.
  - `s2mm_introut`: (Interrupt) reads from stream interface and writes to DDR.

![](imgs/axi-dma-2.png)

![](imgs/axi-dma.png)

#### Learn Rocket

More details in **[chipyard](https://chipyard.readthedocs.io/en/stable/index.html)**.

- RocketTile:
  - Rocket Core: can be swapped for a BOOM core.
  - PTW: Page Table Walker is seperated from the main logic of Rocket Core.
  - L1 Cache
  - TileBus
- SystemBus: the TileLink network that sits between the tiles and the L2 agents and MMIO peripherals.
- ControlBus: connects standard peripherals like BootRom, PLIC, CLINT and the Debug Unit.
  - BootROM: contains first stage bootloader and device tree.
  - PLIC: aggregates and masks device interrupts and external interrupts.
  - CLINT: contains software interrupts and timer interrupts for CPU.
  - Debug: can be used to load data or instructions to memory or pull data from memory.
- PeripheryBus: connects additional peripherals like the NIC and Block Device.

![](imgs/rocketchip-diagram.png)

#### How to edit Rocket in IDEA (Linux)

- Download the newest version of [IDEA](https://www.jetbrains.com/idea/download/download-thanks.html?platform=linux)
- Activate IDEA using code in this [blog](https://www.ajihuo.com/idea/4222.html).
- Clone the repository and build Rocket to make sure that you can generate verilog files successfully.
- Open the sbt project (root directory of Rocket) in IDEA and you can see sbt settings. (If not, try `Ctrl+Alt+S` and search sbt for settings tab). 
- Select Custom Launcher and set `rocket-chip/sbt-launch.jar` as the source file. **DO NOT** select `Download: library sources` or `Download: sbt sources`.
- I use following version of java. Others may be OK.

```txt
openjdk version "1.8.0_342"
OpenJDK Runtime Environment (build 1.8.0_342-8u342-b07-0ubuntu1~20.04-b07)
OpenJDK 64-Bit Server VM (build 25.342-b07, mixed mode)
```

### 11.2~11.3

#### Labeled SOC

- Two block designs, `pardcore` and `zynqsoc` are wrapped together by a top module in `system_top.v`.
- AXI interfaces between them are mapped through `address_mapper.v`. E.g. Rocket M_AXI_MEM is mapped from `[0x1_0000_0000, 0x1_8000_0000)` to `[0x8_0000_0000, 0x8_8000_0000)`.
- Main interfaces exposed by Rocket or `pardcore` are listed below:
  - Jtag interfaces (optional)
  - Led (pin connected)
  - M_AXI_MEM: 0x1_0000_0000, 2G
  - M_AXI_MMIO: 0x4000_0000, 1G
  - S_AXI_DMA: frontend bus to L2 Cache, 0x0, 8G

With `DefaultConfig` and `ExampleRocketSystem`, Rocket exposes a MMIO-AXI4 interface and a MEM-AXI4 interface to peripherals.

MMIO-AXI interface does not alloc burst transactions:


#### Zynq UltraScale+MPSoC

This device has 4 different power domains:
- LPD: Low-power domain
- FPD: Full-power domain
- PLPD: PL power domain
- BPD: Battery power domain

![](imgs/pl2ps-axi.png)

AXI Interfaces:

- High Performance AXI Masters: Access from the PL to the double data rate (DDR).
  - 2 S_AXI_HPCn_FPD: connected to the Cache Coherent Interconnect (CCI).
  - 4 S_AXI_HPn_FPD: connected directry to the DDR interface for memory access.
- Inbound AXI Slaves:
  - 1 M_AXI_HPM0_LPD: low-latency slave interface, provides communication between the PS and the PL from the LPD.
  - 2 M_AXI_HPMn_FPD: from the FPD.

Interrupts:

- Inbound interrupts to PL:
  - 100 LPD peripherals
  - 64 FPD peripherals
- Outbound interrupts from PL:
  - 16 shared peripheral interrupts to the PS
  - 4 Inter-Process Interrupts, 4 FIQs and 4 IRQs to the APU
  - 4 Inter-Processor Interrupts, 2 nFIQs and 2 nIRQs to the RPU

Clocks: 4 clock signals from PS to PL. PL should not depend on implicit sychronization between the clocks incoming from the PS.

EMIO: a easy way to bi-directionally link the LPD to the PL.

#### AXI Support

- AXI4 requires a single address and then bursts up to 256 words of data. AXI-Lite doest not support burst.
- Memory-Mapped Protocols: (AXI3, AXI4, AXI-Lite) all transactions invovle the concept of transferring a target address within a system memory space and data. 
- AXI4-Stream: Focused on a data-centric and data-flow paradigm where the concept of an address is not present or not required. 
- Infrastructure IP: A building block used to help assemble systems.
  - AXI Register slices (for pipelining)
  - AXI FIFOs (for buffering/clock conversion)
  - AXI Inerconnect and AXI SmartConnect IP (for connecting memory-mapped IP together)
  - AXI Direct Memory Access engines (for memory-mapped to stream conversion)
  - AXI Performance Monitors and Protocol Checkers (for analysis and debug)
  - AXI Verificaton IP (for simulation based verfication and performance analysis)
  
#### Xilinx IPs

AXI Clock Converter

Processor System Reset
- `ext_reset_in`: active-low by default (configurable)
- After `ext_reset_in` becomes active, `bus_struct_reset` and `interconnect_areset` become inactive first, then `peripheral_reset` and `peripheral_areset`, then `mb_reset`.

**Copy a hier between block designs**:

```tcl
write_bd_tcl -hier_blks [get_bd_cells <hier_name>] <hier_file>.tcl
source <hier_file>.tcl
create_hier_cell_<hier_name> <parent_cell> <new_hier_name>
```

**Generate .tcl of the block design**:

```tcl
write_bd_tcl -verbose -bd_name uintr_soc -force <tcl_filename>
```

aximm(1.0) AXI interface configurations:
- Num Write/Read Outstanding
- Supports Narrow Burst
- Id Width
- User Signals:
  - Buser Width
  - Ruser Width
  - Wuser Width
  - Aruser Width
  - Awuser Width

AXI ID:
- Indicates a processing "thread" if the master supports multiple threads (operations that can occur in parallel).
- The AXI interconnect logic between the AXI master and AXI slave might add extra bits to the AWID, ARID and WID signals generated by the AXI master so that it can route any responses from the final slave on the R or B channels back to the correct AXI master, but those additional ID bits would not be seen by the AXI master, only the AXI slave.

#### TileLink

> **beat**: An AXI 'burst' is a transaction in which multiple data items are transferred based upon a single address, and it is each data item transferred that is referred to as a 'beat'. Since there is only one address transfer, the addresses of each 'beat' in a burst are calculated based on the transaction type (INCR, FIXED or WRAP).The AXI3 protocol allows up to 16 beats in any burst transaction, whereas the AXI4 protocol allows for up to 256 beats in an INCR type burst transaction.

#### 11.7

Mafile: 
- = basic assign
- := assign and overwrite
- ?= assign by default
- += push back 

Run `mill -i mill.scalalib.GenIdea/idea`.

Operator `>` in bash scripts:
- `> file`: redirects stdout to file
- `1> file`: redirects stdout to file
- `2> file`: redirects stderr to file
-  `&> file`(may not work on older systems): redirects stdout and stderr to file
-  `> file > 2>&1`(older): redirects stdout and stderr to file

`/dev/null`: a null device

[mem sections](https://www.nongnu.org/avr-libc/user-manual/mem_sections.html)
The ,"ax",@progbits tells the assembler that the section is allocatable ("a"), executable ("x") and contains data ("@progbits").
For more detailed information on the .section directive, see the gas user manual.

QSPI: Quad serial peripheral interface

------------------

Some thoughts of labeled-RISC-V system:
- Interconnect reset and peripheral reset should be distinguished in a AXI Interconnect IP. `ARESETN` uses `interconnect_reset` from Processor System Reset while `S0x_/M0x_ARESETN` uses `peripheral_reset`.
- No need to use DMA in uintr project, Uart is enough.
- Uart 16550 can run at a higher baudrate than Uartlite.
- PL can see 4 uarts through Uart 16550 controller from `M_AXI_MMIO` address region, while PS can see 4 uarts through Uartlite controller from `M_AXI_HPM0_LPD`. These are not real uarts but provide channels for communication between PS and PL. PS can use `minicom` to connect to a virtual uart to write to or read from rocket cores in PL.
- I need to know how to use Jtag.

-----------------

#### 11.8

Learn details of Uart 16550, Uartlite and Jtag.

For UART to work the following settings need to be the same on both the transmitting and receiving side:
- Baud Rate
- Parity Bit
- Data bits size
- Stop bits size
- Flow control
A UART frame consists of 5 elements:
- Idle (logic high: historic legacy from telegraphy, in which the line is held high to show that the line and transmitter are not damaged)
- Start bit
- Data bits
- Parity bit
- Stop

Xilinx Virtual Input/Output: A customizable core that can both **monitor** and **drive** internal FPGA signals in real time. An IP core in Vivado IP Catalog.  

I finished building the soc block design with:
- Uart controllers copied from labeled-RISC-V-N
- GPIO controller for leds (see src/constraints)
- Same address map as labeled pre-built images (might be changed later)
- Jtag axi copied from labeled
- Now PS can send one bit interrupt to PL rocket chip

Refactor boot code, adjusting to current block design and address map.

See [discussion](https://support.xilinx.com/s/question/0D52E00006lLhBnSAK/zynq-ultrascale-howto-reset-the-pl?language=en_US) about reset PL.

> I haven't tried yet, but as I understand the code in the AR, the function psu_ps_pl_reset_config_data() does the following:
> 
>  - mask the EMIO95 (register write to 0XFF0A002C) for whatever reason...
>  - set the pin direction to output and enable it (register write to 0XFF0A0344 and 0XFF0A0348)
>  - actual pin toggle using write to 0XFF0A0054
> 
> As this function is already called during psu_init(), the configuration is already done and the reset can be toggled by writing to 0XFF0A0054.

In file proj/rocket-chip-zcu102.gen/sources_1/bd/soc/ip/soc_zynq_ultra_ps_e_0_1/psu_init.c, I found the code:

```c
PSU_Mask_Write(GPIO_DATA_5_OFFSET, 0xFFFFFFFFU, 0x00000000U);
mask_delay(1);
PSU_Mask_Write(GPIO_DATA_5_OFFSET, 0xFFFFFFFFU, 0x80000000U);
```

The function `PSU_Mask_Write` writes masked bits in target register.

```c
static
void PSU_Mask_Write(unsigned long offset, unsigned long mask, unsigned long val)
{
	unsigned long RegVal = 0x0;

	RegVal = Xil_In32(offset);
	RegVal &= ~(mask);
	RegVal |= (val & mask);
	Xil_Out32(offset, RegVal);
}
```

So I did the same job in reset procedure:
- First mmap the mmio address `0xFF0A0054`.
- Write to the address with `0x00000000`, then `0x80000000`.